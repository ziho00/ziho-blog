<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 中的 this 指向 | 学习前端</title>
    <meta name="description" content="归纳前端学习知识点">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.3fcecfc3.css" as="style"><link rel="preload" href="/blog/assets/js/app.1b5d2ea8.js" as="script"><link rel="preload" href="/blog/assets/js/2.daa6c974.js" as="script"><link rel="preload" href="/blog/assets/js/25.f6ebf531.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.368f4418.js"><link rel="prefetch" href="/blog/assets/js/11.0e2a5e23.js"><link rel="prefetch" href="/blog/assets/js/12.782e7b90.js"><link rel="prefetch" href="/blog/assets/js/13.4527dea8.js"><link rel="prefetch" href="/blog/assets/js/14.c5011f64.js"><link rel="prefetch" href="/blog/assets/js/15.db35c99c.js"><link rel="prefetch" href="/blog/assets/js/16.e394df60.js"><link rel="prefetch" href="/blog/assets/js/17.65fd8811.js"><link rel="prefetch" href="/blog/assets/js/18.b12649db.js"><link rel="prefetch" href="/blog/assets/js/19.de123a3f.js"><link rel="prefetch" href="/blog/assets/js/20.c485b6fe.js"><link rel="prefetch" href="/blog/assets/js/21.2b520b34.js"><link rel="prefetch" href="/blog/assets/js/22.7aa61d5e.js"><link rel="prefetch" href="/blog/assets/js/23.ebbe3dc4.js"><link rel="prefetch" href="/blog/assets/js/24.1f9bacd8.js"><link rel="prefetch" href="/blog/assets/js/26.4832d624.js"><link rel="prefetch" href="/blog/assets/js/27.a99b60cd.js"><link rel="prefetch" href="/blog/assets/js/28.5ed9e5a5.js"><link rel="prefetch" href="/blog/assets/js/3.46d875a2.js"><link rel="prefetch" href="/blog/assets/js/4.5f364518.js"><link rel="prefetch" href="/blog/assets/js/5.b7b47752.js"><link rel="prefetch" href="/blog/assets/js/6.32a7d057.js"><link rel="prefetch" href="/blog/assets/js/7.b55bc2ee.js"><link rel="prefetch" href="/blog/assets/js/8.69b2032f.js"><link rel="prefetch" href="/blog/assets/js/9.a325d718.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.3fcecfc3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">学习前端</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端入门学习路线</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>html学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>浏览器工作原理</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/browserWork/1.html" class="sidebar-link">浏览器工作原理</a></li><li><a href="/blog/browserWork/2.html" class="sidebar-link">从输入URL到页面展示，中间发生了什么？</a></li><li><a href="/blog/browserWork/3.html" class="sidebar-link">JS中的作用域</a></li><li><a href="/blog/browserWork/4.html" class="active sidebar-link">JS 中的 this 指向</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/browserWork/4.html#全局执行上下文-中的-this" class="sidebar-link">全局执行上下文 中的 this</a></li><li class="sidebar-sub-header"><a href="/blog/browserWork/4.html#函数执行上下文-中的-this" class="sidebar-link">函数执行上下文 中的 this</a></li><li class="sidebar-sub-header"><a href="/blog/browserWork/4.html#es6箭头函数" class="sidebar-link">ES6箭头函数</a></li></ul></li><li><a href="/blog/browserWork/5.html" class="sidebar-link">call、apply、bind的实现</a></li><li><a href="/blog/browserWork/6.html" class="sidebar-link">JS 数据类型</a></li><li><a href="/blog/browserWork/7.html" class="sidebar-link">JS中的数据存储</a></li><li><a href="/blog/browserWork/8.html" class="sidebar-link">JS垃圾回收</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js基础</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-中的-this-指向"><a href="#js-中的-this-指向" class="header-anchor">#</a> JS 中的 this 指向</h1> <p>在JS中，<strong>this指向其实是跟指向上下文/执行环境绑定的</strong></p> <h2 id="全局执行上下文-中的-this"><a href="#全局执行上下文-中的-this" class="header-anchor">#</a> 全局执行上下文 中的 this</h2> <p>当我们在全局环境下执行下面代码时</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(this)
</code></pre></div><p>会发现打印出来的结果为window对象，所以我们可以得知，在全局执行环境中的this指向为window对象，这也是作用域链最开始的节点。</p> <h2 id="函数执行上下文-中的-this"><a href="#函数执行上下文-中的-this" class="header-anchor">#</a> 函数执行上下文 中的 this</h2> <h3 id="默认调用"><a href="#默认调用" class="header-anchor">#</a> 默认调用</h3> <p>我们再来看下面的代码</p> <div class="language- extra-class"><pre class="language-text"><code>function foo () {
    console.log(this)
}
foo()
</code></pre></div><p>我们发现控制台输出的还是window对象，这也说明在全局环境中调用一个函数时，this指向为全局对象window。</p> <p>那我们能改变函数中的this指向吗?</p> <p>当然!JS还为我们提供了相应的方法 apply / call / bind</p> <div class="language- extra-class"><pre class="language-text"><code>this.name = &quot;test&quot;

let obj = {
    name: &quot;test2&quot;
}

function say() {
    console.log(this.name)
}
say() // test
say.call(obj) // test2
</code></pre></div><p>apply/call/bind功能都是相似的，只是使用方法的不同，详情可以自行到 <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener noreferrer">MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 上查看</p> <h3 id="对象调用"><a href="#对象调用" class="header-anchor">#</a> 对象调用</h3> <p>当一个对象调用自身方法时，this指向为该对象本身</p> <div class="language- extra-class"><pre class="language-text"><code>let obj = {
    name: &quot;ziho&quot;,
    say: function() {
        console.log(this.name)
    }
}
obj.say() // ziho

let fn = obj.say
fn() // 
</code></pre></div><p>上面的结果为 ziho 和 没有值，这也反应了在全局中调用的函数，this 指向为 window</p> <h3 id="通过构造函数设置"><a href="#通过构造函数设置" class="header-anchor">#</a> 通过构造函数设置</h3> <p>当我们使用构造函数new了一个实例时，实例 this 指向谁？</p> <div class="language- extra-class"><pre class="language-text"><code>function Obj() {
    this.name = &quot;ziho&quot;
    this.say = function() {
        console.log(this.name)
    }
}

var obj = new Obj()
</code></pre></div><p>首先我们要先理清楚在 ==new== 的过程中发生了什么？
我们把上面代码作为例子分析：</p> <ul><li>首先创建一个空对象 o</li> <li>调用 Obj.call(o) 所以当调用构造函数时 构造函数的执行上下文中的this 就是该对象</li> <li>执行 o.<strong>proto</strong> = Obj.prototype (在JS原型链中，实例中存在一个属性__proto__ 指向 原型对象 *.prototype)</li> <li>然后调用构造函数，在构造函数中 this 指向对象 o</li> <li>返回对象 o 赋值给 变量 obj</li></ul> <blockquote><p>new 实现</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function myNew () {
    let fn = Array.prototype.shift.call(arguments) // 伪数组使用shift方法
    if(typeof fn !== 'function'){
        throw new TypeError(`${fn} is not a function`)
    }
    let o = new Object()
    o.__proto__ = fn.prototype
    let res = fn.apply(o, arguments)
    return res instanceof Obj ? res : o
}
</code></pre></div><p>所以通过new创建的对象，在构造函数中，this 指向就是该对象</p> <p>但是 this 的设计也有很多缺陷，如：</p> <div class="language- extra-class"><pre class="language-text"><code>
var myObj = {
  name : &quot;test&quot;, 
  showThis: function(){
    console.log(this) // { name: &quot;test&quot;, showThis: fn }
    function bar(){
        console.log(this) // window对象
        }
    bar()
  }
}
myObj.showThis()
</code></pre></div><p>从上面的代码我们看到 首先输出的 this 指向为该实例myObj,但是再接下来的bar()中输出的却是 window 对象，这个结果就让人不解了。这是因为在JS中，<strong>嵌套函数中的 this 不会从外层函数中继承</strong>，所以为了解决这样的问题我们通常会用一个变量保存当前执行上下文的this，防止this指向在意料之外的位置</p> <div class="language- extra-class"><pre class="language-text"><code>showThis: function(){
    console.log(this) // { name: &quot;test&quot;, showThis: fn }
    let self = this
    function bar(){
        console.log(self) // { name: &quot;test&quot;, showThis: fn }
        }
    bar()
}
</code></pre></div><h2 id="es6箭头函数"><a href="#es6箭头函数" class="header-anchor">#</a> ES6箭头函数</h2> <p>ES6中的箭头函数也可以解决上面的问题</p> <div class="language- extra-class"><pre class="language-text"><code>showThis: function(){
    console.log(this) // { name: &quot;test&quot;, showThis: fn }
    let bar = () =&gt; {
        console.log(this) // { name: &quot;test&quot;, showThis: fn }
    }
    bar()
}
</code></pre></div><p>这是因为 ES6 中的<strong>箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数，即箭头函数的 this 就是它外层函数的 this</strong>。</p> <p>还有一个缺陷就是从默认调用的函数this指向为window对象</p> <p>因为这样会导致发送很多意料之外的错误，也很容易打破数据边界。所以，如果要让函数的执行上下文的this指向某个对象，最好还是使用call/apply来操作。或者设置 JS 的严格模式，这样当默认调用函数时函数执行上下文的this指向为undefined。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/browserWork/3.html" class="prev">
        JS中的作用域
      </a></span> <span class="next"><a href="/blog/browserWork/5.html">
        call、apply、bind的实现
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.1b5d2ea8.js" defer></script><script src="/blog/assets/js/2.daa6c974.js" defer></script><script src="/blog/assets/js/25.f6ebf531.js" defer></script>
  </body>
</html>
