(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{243:function(e,n,t){"use strict";t.r(n);var s=t(28),r=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"实现一个-promise-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现一个-promise-函数"}},[e._v("#")]),e._v(" 实现一个 promise 函数")]),e._v(" "),t("p",[e._v("首先我们要知道 promise 的一些基本的规则。")]),e._v(" "),t("p",[e._v("promise 有三种状态:pending(初始状态)、rejected(意味着操作失败)、fulfilled(意味着操作成功完成)")]),e._v(" "),t("p",[e._v("pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。"),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise",target:"_blank",rel:"noopener noreferrer"}},[e._v("详细规则可以看这~"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("可以理解为当promise实例的状态转变后(即从pending转变为rejected或fulfilled),就会一直保持该状态不会改变。这就跟他的意思承诺相似。")]),e._v(" "),t("p",[e._v("这个promise其实还没完善，想实现更加完善的promise可以自行到网上查阅相关文档")]),e._v(" "),t("blockquote",[t("p",[e._v("简单版")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const PENDING = 'pending' // 初始状态\nconst FULFILLED = 'fulfilled' // 意味着操作成功完成\nconst REJECTED = 'rejected' // 意味着操作失败\nclass MyPromise {\n    constructor(fn) {\n        this.state = PENDING\n        this.result = null\n        this.reason = null\n        this.onResolveQueue = []\n        this.onRejectedQueue = []\n\n        const resolve = result => {\n            setTimeout(() => {\n                if(this.state === PENDING){\n                    this.state = FULFILLED\n                    this.result = result\n                    this.onResolveQueue.map(cb => {\n                        cb(this.result)\n                    })\n                }\n            })\n        }\n\n        const reject = reason => {\n            setTimeout(() => {\n                if(this.state === PENDING){\n                    this.state = REJECTED\n                    this.reason = reason\n                    this.onRejectedQueue.map(cb => {\n                        cb(this.reason)\n                    })\n                }\n            })\n        }\n    }\n\n    then(onResolve, onRejected) {\n        typeof onResolve === 'function' && this.onResolveQueue.push(onResolve)\n        typeof onRejected === 'function' && this.onRejectedQueue.push(onRejected)\n        return this\n    }\n}\n")])])]),t("blockquote",[t("p",[e._v("规范版")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const PENDING = 'pending' // 初始状态\nconst FULFILLED = 'fulfilled' // 意味着操作成功完成\nconst REJECTED = 'rejected' // 意味着操作失败\n\nclass AjPromise {\n  constructor(fn) {\n    this.state = PENDING;\n    this.value = null;\n    this.reason = null;\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n    const resolve = value => {\n      if (value instanceof Promise) {\n        return value.then(resolve, reject);\n      }\n      setTimeout(() => {\n        if (this.state === PENDING) {\n          this.state = FULFILLED;\n          this.value = value;\n          this.onFulfilledCallbacks.map(cb => {\n            cb = cb(this.value);\n          });\n        }\n      });\n    };\n    const reject = reason => {\n      setTimeout(() => {\n        if (this.state === PENDING) {\n          this.state = REJECTED;\n          this.reason = reason;\n          this.onRejectedCallbacks.map(cb => {\n            cb = cb(this.reason);\n          });\n        }\n      });\n    };\n    try {\n      fn(resolve, reject);\n    } catch (e) {\n      reject(e);\n    }\n  }\n  then(onFulfilled, onRejected) {\n    let newPromise;\n\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    onRejected =\n      typeof onRejected === 'function'\n        ? onRejected\n        : reason => {\n            throw reason;\n          };\n    if (this.state === FULFILLED) {\n      return (newPromise = new AjPromise((resolve, reject) => {\n        setTimeout(() => {\n          try {\n            let x = onFulfilled(this.value);\n            resolvePromise(newPromise, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }));\n    }\n    if (this.state === REJECTED) {\n      return (newPromise = new AjPromise((resolve, reject) => {\n        setTimeout(() => {\n          try {\n            let x = onRejected(this.reason);\n            resolvePromise(newPromise, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }));\n    }\n    if (this.state === PENDING) {\n      return (newPromise = new AjPromise((resolve, reject) => {\n        this.onFulfilledCallbacks.push(value => {\n          try {\n            let x = onFulfilled(value);\n            resolvePromise(newPromise, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        });\n        this.onRejectedCallbacks.push(reason => {\n          try {\n            let x = onRejected(reason);\n            resolvePromise(newPromise, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }));\n    }\n  }\n}\nfunction resolvePromise(promise2, x, resolve, reject) {\n  if (x === promise2) {\n    reject(new TypeError('循环引用'));\n  }\n  if (x instanceof AjPromise) {\n    if (x.state === PENDING) {\n      x.then(\n        y => {\n          resolvePromise(promise2, y, resolve, reject);\n        },\n        reason => {\n          reject(reason);\n        }\n      );\n    } else {\n      x.then(resolve, reject);\n    }\n  } else if (x && (typeof x === 'function' || typeof x === 'object')) {\n    let called = false;\n    try {\n      let then = x.then;\n      if (typeof then === 'function') {\n        then.call(\n          x,\n          y => {\n            if (called) return;\n            called = true;\n            resolvePromise(promise2, y, resolve, reject);\n          },\n          r => {\n            if (called) return;\n            called = true;\n            reject(r);\n          }\n        );\n      } else {\n        resolve(x);\n      }\n    } catch (e) {\n      if (called) return;\n      called = true;\n      reject(e);\n    }\n  } else {\n    resolve(x);\n  }\n}\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);